# JAVA
****
## 基础

----------

### 基础概念与常识

***********

#### 1、Java 语言有哪些特点?

1. 面向对象（封装，继承，多态）
2. 平台无关性（ Java 虚拟机实现平台无关性）
3. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
4. 编译与解释并存  

#### 2、JVM vs JDK vs JRE

1. Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。JVM 并不是只有一种！<br><br>
2. JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。<br><br>
3. JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

#### 3、什么是字节码?采用字节码的好处是什么?

&emsp;&emsp;在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以，Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

#### 4、为什么说 Java 语言“编译与解释并存”？

1. 编译型 ：编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
2. 解释型 ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。
3. 这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

#### 5、Java 和 C++ 的区别?

1. Java 不提供指针来直接访问内存，程序内存更加安全
2. Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
3. Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。

*********
### 基本语法
*******

#### 1、标识符和关键字的区别是什么？

&emsp;&emsp;在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符 。简单来说，标识符就是一个名字。有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是关键字。简单来说，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。

#### 2、自增自减运算符

&emsp;&emsp;++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。

***
### 变量
***

#### 1、成员变量与局部变量的区别？

1. 定义的位置不一样<br>
局部变量：在方法的内部; 成员变量：在方法的外部，直接写在类当中。
2. 作用范围不一样<br>
局部变量：只有方法当中才可以使用，出了方法就不能再用; 成员变量：整个类全都可以通用。
3. 默认值不一样<br>
局部变量：没有默认值，进行手动赋值; 成员变量：如果没有赋值，会有默认值，规则和数组一样
4. 内存位置不一样<br>
局部变量：栈内存; 成员变量：堆内存
5. 生命周期不一样<br>
局部变量：随着方法进栈诞生，随着方法出栈消失; 成员变量：随着对象创建而诞生，被垃圾回收而消失

#### 2、静态变量有什么作用？
&emsp;&emsp;静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。通常情况下，静态变量会被 final 关键字修饰成为常量。

#### 3、字符型常量和字符串常量的区别?
1. 形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
2. 含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
3. 占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节。

***
### 方法
***

#### 1、静态方法为什么不能调用非静态成员?
1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

#### 2、静态方法和实例方法有何不同？
1. 调用方式<br>
在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。
2. 访问类成员是否存在限制<br>
静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

#### 3、重载和重写有什么区别？
1. 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
2. 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

***
### 基本数据类型
***

#### 1、基本类型和包装类型的区别？

1. Java有八种基本数据类型：byte、short、int、long、float、double、boolean、char<br>
Java为其提供了8种对应的包装类：Byte、Short、Integer、Long、Float、Double、Boolean、Character
2. 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
3. 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
4. 相比于对象类型， 基本数据类型占用的空间非常小。

#### 2、包装类型的缓存机制
&emsp;&emsp;Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。

#### 3、什么是自动拆装箱？

1. 装箱：将基本类型用它们对应的引用类型包装起来；
2. 拆箱：将包装类型转换为基本数据类型；

#### 4、如何解决浮点数运算的精度丢失问题？

&emsp;&emsp;BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。

***
### 基本数据类型
***

#### 1、面向对象和面向过程的区别
两者的主要区别在于解决问题的方式不同：
1. 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
2. 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。另外，面向对象开发的程序一般更易维护、易复用、易扩展。

#### 2、创建一个对象用什么运算符?对象实体与对象引用有何不同?
&emsp;&emsp;new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

#### 3、对象的相等和引用相等的区别
1. 对象的相等一般比较的是内存中存放的内容是否相等。
2. 引用相等一般比较的是他们指向的内存地址是否相等。

#### 4、构造方法有哪些特点？是否可被 override?

1. 名字与类名相同。
2. 没有返回值，但不能用 void 声明构造函数。
3. 生成类的对象时自动执行，无需调用。
4. 构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

#### 5、接口和抽象类有什么共同点和区别
共同点 ：
1. 都不能被实例化。
2. 都可以包含抽象方法。
3. 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。

区别 ：
1. 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
2. 一个类只能继承一个类，但是可以实现多个接口。
3. 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

#### 6、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？
1. 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），只拷贝基本数据类型，不过浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
2. 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
3. 引用拷贝就是两个不同的引用指向同一个对象。

#### 7、== 和 equals() 的区别
1. 对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，== 比较的是对象的内存地址。
2. equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。
3. 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。（Sting 重写了该方法）

#### 8、hashCode() 有什么用
1. hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。
2. 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 
3. 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。 
4. 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。

#### 9、String、StringBuffer、StringBuilder 的区别？
1. String 是不可变的（String 类中使用 final 关键字修饰字符数组来保存字符串）
2. StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的
3. StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

#### 10、字符串常量池的作用了解吗？
字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

#### 11、intern 方法有什么作用？
String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：
1. 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
2. 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

*****
### 异常
******

#### 1、Exception 和 Error 有什么区别？
在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:
1. Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
2. Error ：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

#### 2、Checked Exception 和 Unchecked Exception 有什么区别？
1. Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常： IO 相关的异常
2. Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException：空指针错误，数组越界错误，类型转换错误

#### 3、Throwable 类常用方法有哪些？
1. String getMessage(): 返回异常发生时的简要描述
2. String toString(): 返回异常发生时的详细信息

#### 4、try-catch-finally 如何使用？
1. try块 ： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
2. catch块 ： 用于处理 try 捕获到的异常。
3. finally 块 ： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

#### 5、finally 中的代码一定会执行吗？
不一定的！在某些情况下，finally 中的代码不会被执行。就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。程序所在的线程死亡。关闭 CPU。

#### 6、如何使用 try-with-resources 代替try-catch-finally？
1. 适用于关闭资源（InputStream、OutputStream 、Scanner 、PrintWriter）和java.lang.AutoCloseable或者 java.io.Closeable 的对象
2. 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。通过使用分号分隔，可以在try-with-resources块中声明多个资源。
3. 没有finally更简洁，自动生成了关闭资源的finally 代码块；而且将scanner.close()抛出的异常和new Scanner()抛出异常，addSuppressed合并到了一起。解决了异常屏蔽。

#### 7、异常使用有哪些需要注意的地方？
1. 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。
2. 抛出的异常信息一定要有意义。
3. 议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。
4. 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。


*****
### 泛型
******
#### 1、泛型的意义和作用是什么？
1. 类型的参数化，就是可以把类型像方法的参数那样传递。
2. 作用：泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。

#### 2、泛型的使用方式有哪几种？
1. 泛型类：泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来
2. 泛型方法：静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>。
3. 泛型接口：（1）实现泛型接口，不指定类型（2）实现泛型接口，指定类型

#### 3、通配符
1. ?号通配符表示可以匹配任意类型
2. 就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。
3. 协变 <? extends T>，类型的上界是 T，参数化类型可能是 T 或 T 的子类。
4. 逆变 <? super T>，表示类型的下界是 T，参数化类型可以是 T 或 T 的超类。

#### 4、通配符和泛型方法
1. 如果参数之间的类型有依赖关系，或者返回值是与参数之间有依赖关系的。那么就使用泛型方法
2. 如果没有依赖关系的，就使用通配符，通配符会灵活一些.

#### 5、泛型擦除
在编译期间，所有的泛型信息都会被擦除，如的String类型，在编译后都会变成object类型。让编译器在源代码级别上，即挡住向集合中插入非法数据。生成的class文件中将不再带有泛形信息，以此使程序运行效率不受到影响，这个过程称之为“擦除”。

****
### 反射
****

#### 1、什么是反射
在运行时获取一个类的所有信息，（包括成员变量，成员方法，构造器等），并且可以操纵类的字段、方法、构造器等部分。

#### 2、反射机制的优缺点
1. 优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利，降低耦合性。
2. 缺点 ：
3. （1）让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。
（2）性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多

#### 3、获取 Class 对象的四种方式
1. 调用类的class属性类获取该类对应的Class对象，即：类名.class
2. 通过 Class.forName()传入类的全路径获取
3. 通过对象实例instance.getClass()获取

****
### 注解
*****
#### 1、 何谓注解？
可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。本质上是继承了Annotation 的特殊接口。

#### 2、注解的解析方法有哪几种？
1. 编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
2. 运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。

****
### SPI
****

#### 1、什么是SPI
根据一个接口，找到项目中要使用的实现类，用户可以根据实际需要启用或者是扩展原来的默认策略。具体来说定义一个接口，第三方实现这个接口，程序运行过程中通过配置信息动态加载第三方实现，从而完成一个动态扩展的机制。
经典案列：数据库驱动，JAVA并没有实现数据库驱动，而是提供了一个接口，由第三方厂商负责实现，程序运行使会根据驱动类型动态加载数据库驱动的实现

####2、和API 有什么区别？
当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。当接口存在于调用方这边时，就是SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。

####3、SPI 的优缺点？
优点：
1. 实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离
2. 提高接口设计的灵活性
缺点：
3. 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
4. 当多个 ServiceLoader 同时 load 时，会有并发问题。


****
### I/O
****

#### 1、