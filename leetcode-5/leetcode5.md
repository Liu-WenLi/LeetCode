字符串变为字符数组：

`char[] charArray = s.toCharArray();`

这道有三种解法：暴力遍历，中心扩散法和动态规划。

暴力遍历（solution1）的时间复杂度是O(n^3)，总体思路是遍历字符串，之后针对每一个字符再遍历，找到所有与该字符相同的字符，并对每一个相同的字符向中心靠近来验证是否为回文子串。在完成所有循环后选择最长的作为结果。

上述方法最容易想到，首先找到首尾相同的字符串再向中心验证，但是因为有三个循环，所以时间复杂度极大。仔细思考一下，在第二次遍历找相同字符时，其实已经遍历了许多字符信息但是都浪费了，因此可以改变思路从中间向两边验证，这样的话可以一边遍历一遍验证是否为回文子串，省了一个循环的时间。

其实在做的时候就已经觉得第二个循环和第三个循环不合理可以合并，但是对于从两边到中间的思路想不到很好的方法做到同时遍历和验证，但是改变思路从中心向两边扩散的话，一切就迎刃而解了。所以改变思路很重要。

这道题的也可以用动态规划来做，因为动态规划不为唯一解和最优解，这里只简单介绍下：首先这道题满足最优子结构

`P(i,j)=P(i+1,j−1)∧(S i == S j)`

其中si代表第i个字符，而动态规划的边界条件为：


`P(i,i)=true`
`P(i,i+1)=(S i ==S i+1)`

最终的答案即为所有 P(i, j) = true，P(i,j)=true 中子串长度的最大值。注意：在状态转移方程中，是从长度较短的字符串向长度较长的字符串进行转移的（从中心到两边），因此一定要注意动态规划的循环顺序。因此首先通过边界条件确定dp数组中P(i,i)=true，再通过增加长度不断判断P(i,j)的值，并最终找到最优解。
