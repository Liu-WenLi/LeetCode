这道题难度很大，这里就讲下解法，思路真的挺难的想不到。这道题用动态规划应该是最快最好的方法。如果用遍历的话，情况太多太复杂，很难全部搞定。动态规划两个难点：一是确定状态转移方程，二是边界情况。

首先是状态转移方程，`f[i][j]`便是第i个字符适配前j个字符，做着题最重要的是搞清楚` * `这个字符是解体的关键。如果不考虑` * `,则状态转移方程非常简单如下：

`f[i][j] = f[i−1][j−1] && s[i]=p[j]`

星号的情况比较复杂，需要考虑`*`号前面的字符是否与当前字符一致，若一致，则有

`f[i][j] = f[i−1][j] or f[i][j−2]` 其中`f[i][j−2]`是指只有一次重复的情况， `f[i−1][j]`是多次重复的情况。

若不一致则有

`f[i][j] = f[i][j−2]`

综上所述状态转移方程如下：

![状态转移方程](C:\Users\刘文力\Desktop\LeetCode\leetcode-10\1.png)

 边界条件为`f[0][0] = ture`意为两个空的字符串正则化匹配。对于`f[0][i]`的情况，若p[i]为`*`则`f[0][i] = f[0][i - 2]`其余全为false。

总结一下，边界条件确实难想，但是先考虑简单情况快速建立起状态转移方程是值得借鉴的。